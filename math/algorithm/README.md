# 各种算法实现



## 0. 带着问题去阅读会事半功倍哦
1. 都有哪些算法？
2. 每个算法是解决什么问题的？
3. 衡量算法的好坏标准是什么？
4. 同类问题各种实现算法的对比？

## 1. 数据结构
1. 数组
2. 链表
3. 栈，调用栈，后进先出Last In, First out
4. 散列表-dict,hash函数？sha
5. 图 , 拓扑排序
6. 树，特殊的图
6. 队列, First in, First out
操作：增、删、改、查

思考：插入时就排序，和全部插入后再排序？

## 1. 排序
算法名称 | 最好时间 | 平均时间 | 最坏时间 | 辅助空间 | 稳定性
---- | --- | --- | ---- | --- | --- 
直接插入 | O(n) | O(n**2) | ---- | O(1) | 稳定 
二分插入 | O(n) | O(n**2) | ---- | O(1) | 稳定 
希尔排序 | O(n) | O(n**1.25) | ---- | O(1) | 不稳定 
冒泡排序 | O(n) | O(n**2) | O(n**2) | O(1) | 稳定 
快速排序 | O(nlgn) | O(nlgn) | O(n**2) | O(lgn) | 不稳定
选择(selection)排序 | O(n**2) | --- | ---- | O(1) | 不稳定 
堆 | O(nlgn) | --- | ---- | O(1) | 不稳定 
归并(merge)排序  | O(nlgn) | --- | ---- | O(n) | 稳定  

参考：https://www.cnblogs.com/alsf/p/6606287.html
思考：把几个函数放在一个图里表示？

## 2. 查找
算法名称 | 最好时间 | 平均时间 | 最坏时间 | 辅助空间 | 稳定性
---- | --- | --- | ---- | --- | --- 
 顺序查找 | --- | --- | ---- | --- | --- 
二分查找 | --- | --- | ---- | --- | --- 
插值查找 | --- | --- | ---- | --- | --- 
斐波那契查找 | --- | --- | ---- | --- | --- 
树表查找 | --- | --- | ---- | --- | --- 
分块查找 | --- | --- | ---- | --- | --- 
哈希查找 | --- | --- | ---- | --- | --- 

参考： https://www.cnblogs.com/yw09041432/p/5908444.html

## 3.图
最短路径问题shortest-path problem
广度优先搜索，breadth-first search BFS
加权图
狄克斯特拉 算法
思考：黏菌路径规划？

## 4.树


https://github.com/egonschiele/grokking_algorithms

算法导论(原书第3版)
第一部分基础知识 
第1章算法在计算中的作用 
1.1算法 
1.2作为一种技术的算法 
思考题 
本章注记 
第2章算法基础 
2.1插入排序 
2.2分析算法 
2.3设计算法 
2.3.1分治法 
2.3.2分析分治算法 
思考题 
本章注记 
第3章函数的增长 
3.1渐近记号 
3.2标准记号与常用函数 
思考题 
本章注记 
第4章分治策略 
4.1最大子数组问题 
4.2矩阵乘法的Strassen算法 
4.3用代入法求解递归式 
4.4用递归树方法求解递归式 
4.5用主方法求解递归式 
4.6证明主定理 
4.6.1对6的幂证明主定理 
4.6.2向下取整和向上取整 
思考题 
本章注记 
第5章概率分析和随机算法 
5.1雇用问题 
5.2指示器随机变量 
5.3随机算法 
*5.4概率分析和指示器随机变量的进一步使用 
5.4.1生日悖论 
5.4.2球与箱子 
5.4.3特征序列 
5.4.4在线雇用问题 
思考题 
本章注记 
第二部分排序和顺序统计量 
第6章堆排序 
6.1堆 
6.2维护堆的性质 
6.3建堆 
6.4堆排序算法 
6.5优先队列 
思考题 
本章注记 
第7章快速排序 
7.1快速排序的描述 
7.2快速排序的性能 
7.3快速排序的随机化版本 
7.4快速排序分析 
7.4.1最坏情况分析 
7.4.2期望运行时间 
思考题 
本章注记 
第8章线性时间排序 
8.1排序算法的下界 
8.2计数排序 
8.3基数排序 
8.4桶排序 
思考题 
本章注记 
第9章中位数和顺序统计量 
9.1最小值和最大值 
9.2期望为线性时间的选择算法 
9.3最坏情况为线性时间的选择算法 
思考题 
本章注记 
第三部分数据结构 
第10章基本数据结构 
10.1栈和队列 
10.2链表 
10.3指针和对象的实现 
10.4有根树的表示 
思考题 
本章注记 
第11章散列表 
11.1直接寻址表 
11.2散列表 
11.3散列函数 
11.3.1除法散列法 
11.3.2乘法散列法 
*11.3.3全域散列法 
11.4开放寻址法 
11.5完全散列 
思考题 
本章注记 
第12章二叉搜索树 
12.1什么是二叉搜索树 
12.2查询二叉搜索树 
12.3插入和删除 
12.4随机构建二叉搜索树 
思考题 
本章注记 
第13章红黑树 
13.1红黑树的性质 
13.2旋转 
13.3插入 
13.4删除 
思考题 
本章注记 
第14章数据结构的扩张 
14.1动态顺序统计 
14.2如何扩张数据结构 
14.3区间树 
思考题 
本章注记 
第四部分高级设计和分析技术 
第15章动态规划 
15.1钢条切割 
15.2矩阵链乘法 
15.3动态规划原理 
15.4最长公共子序列 
15.5最优二叉搜索树 
思考题 
本章注记 
第16章贪心算法 
16.1活动选择问题 
16.2贪心算法原理 
16.3赫夫曼编码 
*16.4拟阵和贪心算法 
*16.5用拟阵求解任务调度问题 
思考题 
本章注记 
第17章摊还分析 
17，1聚合分析 
17.2核算法 
17.3势能法 
17.4动态表 
17.4.1表扩张 
17.4.2表扩张和收缩 
思考题 
本章注记 
第五部分高级数据结构 
第18章B树 
18.1B树的定义 
18.2B树上的基本操作 
18.3从B树中删除关键字 
思考题 
本章注记 
第19章斐波那契堆 
19.1斐波那契堆结构 
19.2可合并堆操作 
19.3关键字减值和删除一个结点 
19.4最大度数的界 
思考题 
本章注记 
第20章van Emde Boas树 
20.1基本方法 
20.2递归结构 
20.2.1原型van Emde Boas结构 
20.2.2原型van Emde Boas结构上的操作 
20.3van Emde Boas树及其操作 
20.3.1van Emde Boas树 
20.3.2van Emde Boas树的操作 
思考题 
本章注记 
第21章用于不相交集合的数据结构 
21.1不相交集合的操作 
21.2不相交集合的链表表示 
21.3不相交集合森林 
*21.4带路径压缩的按秩合并的分析 
思考题 
本章注记 
第六部分图算法 
第22章基本的图算法 
22.1图的表示 
22.2广度优先搜索 
22.3深度优先搜索 
22.4拓扑排序 
22.5强连通分量 
思考题 
本章注记 
第23章最小生成树 
23.1最小生成树的形成 
23.2Kruskal算法和Prim算法 
思考题 
本章注记 
第24章单源最短路径 
24.1Bellman—Ford算法 
24.2有向无环图中的单源最短路径问题 
24.3Dijkstra算法 
24.4差分约束和最短路径 
24.5最短路径性质的证明 
思考题 
本章注记 
第25章所有结点对的最短路径问题 
25.1最短路径和矩阵乘法 
25.2Floyd—Warshall算法 
25.3用于稀疏图的Johnson算法 
思考题 
本章注记 
第26章最大流 
26.1流网络 
26.2Ford—Fulkerson方法 
26.3最大二分匹配 
*26.4推送一重贴标签算法 
*26.5前置重贴标签算法 
思考题 
本章注记 
第七部分算法问题选编 
第27章多线程算法 
27.1动态多线程基础 
27.2多线程矩阵乘法 
27.3多线程归并排序 
思考题 
本章注记 
第28章矩阵运算 
28.1求解线性方程组 
28.2矩阵求逆 
28.3对称正定矩阵和最小二乘 
逼近 
思考题 
本章注记 
第29章线性规划 
29.1标准型和松弛型 
29.2将问题表达为线性规划 
29.3单纯形算法 
29.4对偶性 
29.5初始基本可行解 
思考题 
本章注记 
第30章多项式与快速傅里叶变换 
30.1多项式的表示 
30.2DFT与FFT 
30.3高效FFT实现 
思考题 
本章注记 
第31章数论算法 
31.1基础数论概念 
31.2最大公约数 
31.3模运算 
31.4求解模线性方程 
31.5中国余数定理 
31.6元素的幂 
31.7RSA公钥加密系统 
*31.3素数的测试 
*31.9整数的因子分解 
思考题 
本章注记 
第32章字符串匹配 
32.1朴素字符串匹配算法 
32.2Rabin—Karp算法 
32.3利用有限自动机进行字符串匹配 
*32.4Knuth—Morris—Pratt算法 
思考题 
本章注记 
第33章计算几何学 
33.1线段的性质 
33.2确定任意一对线段是否相交 
33.3寻找凸包 
33.4寻找最近点对 
思考题 
本章注记 
第34章NP完全性 
34.1多项式时间 
34.2多项式时间的验证 
34.3NP完全性与可归约性 
34.4NP完全性的证明 
34.5NP完全问题 
34.5.1团问题 
34.5.2顶点覆盖问题 
34.5.3哈密顿回路问题 
34.5.4旅行商问题 
34.5.5子集和问题 
思考题 
本章注记 
第35章近似算法 
35.1顶点覆盖问题 
35.2旅行商问题 
35.2.1满足三角不等式的旅行商问题 
35.2.2一般旅行商问题 
35.3集合覆盖问题 
35.4随机化和线性规划 
35.5子集和问题 
思考题 
本章注记 
第八部分附录：数学基础知识 
附录A求和 
A.1求和公式及其性质 
A.2确定求和时间的界 
思考题 
附录注记 
附录B集合等离散数学内容 
B.1集合 
B.2关系 
B.3函数 
B.4图 
B.5树 
B.5.1自由树 
B.5.2有根树和有序树 
B.5.3二叉树和位置树 
思考题 
附录注记 
附录C计数与概率 
C.1计数 
C.2概率 
C.3离散随机变量 
C.4几何分布与二项分布 
思考题 
附录注记 
附录D矩阵 
D.1矩阵与矩阵运算 
D.2矩阵的基本性质 
思考题 
附录注记 
参考文献 
索引


第1章 基础 
1.1 基础编程模型 
1.1.1 Java程序的基本结构 
1.1.2 原始数据类型与表达式 
1.1.3 语句 
1.1.4 简便记法 
1.1.5 数组 
1.1.6 静态方法 
1.1.7 API 
1.1.8 字符串 
1.1.9 输入输出 
1.1.10 二分查找 
1.1.11 展望 
1.2 数据抽象 
1.2.1 使用抽象数据类型 
1.2.2 抽象数据类型举例 
1.2.3 抽象数据类型的实现 
1.2.4 更多抽象数据类型的实现 
1.2.5 数据类型的设计 
1.3 背包、队列和栈 
1.3.1 API 
1.3.2 集合类数据类型的实现 
1.3.3 链表 
1.3.4 综述 
1.4 算法分析 
1.4.1 科学方法 
1.4.2 观察 
1.4.3 数学模型 
1.4.4 增长数量级的分类 
1.4.5 设计更快的算法 
1.4.6 倍率实验 
1.4.7 注意事项 
1.4.8 处理对于输入的依赖 
1.4.9 内存 
1.4.10 展望 
1.5 案例研究：union—find算法 
1.5.1 动态连通性 
1.5.2 实现 
1.5.3 展望 
第2章 排序 
2.1 初级排序算法 
2.1.1 游戏规则 
2.1.2 选择排序 
2.1.3 插入排序 
2.1.4 排序算法的可视化 
2.1.5 比较两种排序算法 
2.1.6 希尔排序 
2.2 归并排序 
2.2.1 原地归并的抽象方法 
2.2.2 自顶向下的归并排序 
2.2.3 自底向上的归并排序 
2.2.4 排序算法的复杂度 
2.3 快速排序 
2.3.1 基本算法 
2.3.2 性能特点 
2.3.3 算法改进 
2.4 优先队列 
2.4.1 API 
2.4.2 初级实现 
2.4.3 堆的定义 
2.4.4 堆的算法 
2.4.5 堆排序 
2.5 应用 
2.5.1 将各种数据排序 
2.5.2 我应该使用哪种排序算法 
2.5.3 问题的归约 
2.5.4 排序应用一览 
第3章 查找 
3.1 符号表 
3.1.1 API 
3.1.2 有序符号表 
3.1.3 用例举例 
3.1.4 无序链表中的顺序查找 
3.1.5 有序数组中的二分查找 
3.1.6 对二分查找的分析 
3.1.7 预览 
3.2 二叉查找树 
3.2.1 基本实现 
3.2.2 分析 
3.2.3 有序性相关的方法与删除操作 
3.3 平衡查找树 
3.3.12—3查找树 
3.3.2 红黑二叉查找树 
3.3.3 实现 
3.3.4 删除操作 
3.3.5 红黑树的性质 
3.4 散列表 
3.4.1 散列函数 
3.4.2 基于拉链法的散列表 
3.4.3 基于线性探测法的散列表 
3.4.4 调整数组大小 
3.4.5 内存使用 
3.5 应用 
3.5.1 我应该使用符号表的哪种实现 
3.5.2 集合的API 
3.5.3 字典类用例 
3.5.4 索引类用例 
3.5.5 稀疏向量 
第4章 图 
4.1 无向图 
4.1.1 术语表 
4.1.2 表示无向图的数据类型 
4.1.3 深度优先搜索 
4.1.4 寻找路径 
4.1.5 广度优先搜索 
4.1.6 连通分量 
4.1.7 符号图 
4.1.8 总结 
4.2 有向图 
4.2.1 术语 
4.2.2 有向图的数据类型 
4.2.3 有向图中的可达性 
4.2.4 环和有向无环图 
4.2.5 有向图中的强连通性 
4.2.6 总结 
4.3 最小生成树 
4.3.1 原理 
4.3.2 加权无向图的数据类型 
4.3.3 最小生成树的API和测试用例 
4.3.4 Prim算法 
4.3.5 Prim算法的即时实现 
4.3.6 Kruskal算法 
4.3.7 展望 
4.4 最短路径 
4.4.1 最短路径的性质 
4.4.2 加权有向图的数据结构 
4.4.3 最短路径算法的理论基础 
4.4.4 Dijkstra算法 
4.4.5 无环加权有向图中的最短路径算法 
4.4.6 一般加权有向图中的最短路径问题 
4.4.7 展望 
第5章 字符串 
5.1 字符串排序 
5.1.1 键索引计数法 
5.1.2 低位优先的字符串排序 
5.1.3 高位优先的字符串排序 
5.1.4 三向字符串快速排序 
5.1.5 字符串排序算法的选择 
5.2 单词查找树 
5.2.1 单词查找树 
5.2.2 单词查找树的性质 
5.2.3 三向单词查找树 
5.2.4 三向单词查找树的性质 
5.2.5 应该使用字符串符号表的哪种实现 
5.3 子字符串查找 
5.3.1 历史简介 
5.3.2 暴力子字符串查找算法 
5.3.3 Knuth—Morris—Pratt子字符串查找算法 
5.3.4 Boyer—Moore字符串查找算法 
5.3.5 Rabin—Karp指纹字符串查找算法 
5.3.6 总结 
5.4 正则表达式 
5.4.1 使用正则表达式描述模式 
5.4.2 缩略写法 
5.4.3 正则表达式的实际应用 
5.4.4 非确定有限状态自动机 
5.4.5 模拟NFA的运行 
5.4.6 构造与正则表达式对应的NFA 
5.5 数据压缩 
5.5.1 游戏规则 
5.5.2 读写二进制数据 
5.5.3 局限 
5.5.4 热身运动：基因组 
5.5.5 游程编码 
5.5.6 霍夫曼压缩 
第6章 背景 

第1 章算法简介 1
1.1 引言 1
1.1.1 性能方面 1
1.1.2 问题解决技巧 2
1.2 二分查找 2
1.2.1 更佳的查找方式 4
1.2.2 运行时间 8
1.3 大O表示法 8
1.3.1 算法的运行时间以不同的速度增加 9
1.3.2 理解不同的大O运行时间 10
1.3.3 大O表示法指出了最糟情况下的运行时间 12
1.3.4 一些常见的大O运行时间 12
1.3.5 旅行商 13
1.4 小结 15
第2 章选择排序 16
2.1 内存的工作原理 16
2.2 数组和链表 18
2.2.1 链表 19
2.2.2 数组 20
2.2.3 术语 21
2.2.4 在中间插入 22
2.2.5 删除 23
2.3 选择排序 25
2.4 小结 28
第3 章递归 29
3.1 递归 29
3.2 基线条件和递归条件 32
3.3 栈 33
3.3.1 调用栈 34
3.3.2 递归调用栈 36
3.4 小结 40
第4 章快速排序 41
4.1 分而治之 41
4.2 快速排序 47
4.3 再谈大O表示法 52
4.3.1 比较合并排序和快速排序 53
4.3.2 平均情况和最糟情况 54
4.4 小结 57
第5 章散列表 58
5.1 散列函数 60
5.2 应用案例 63
5.2.1 将散列表用于查找 63
5.2.2 防止重复 64
5.2.3 将散列表用作缓存 66
5.2.4 小结 68
5.3 冲突 69
5.4 性能 71
5.4.1 填装因子 72
5.4.2 良好的散列函数 74
5.5 小结 75
第6 章广度优先搜索 76
6.1 图简介 77
6.2 图是什么 79
6.3 广度优先搜索 79
6.3.1 查找最短路径 82
6.3.2 队列 83
6.4 实现图 84
6.5 实现算法 86
6.6 小结 93
第7 章狄克斯特拉算法 94
7.1 使用狄克斯特拉算法 95
7.2 术语 98
7.3 换钢琴 100
7.4 负权边 105
7.5 实现 108
7.6 小结 116
第8 章贪婪算法 117
8.1 教室调度问题 117
8.2 背包问题 119
8.3 集合覆盖问题 121
8.4 NP完全问题 127
8.4.1 旅行商问题详解 127
8.4.2 如何识别NP完全问题 131
8.5 小结 133
第9 章动态规划 134
9.1 背包问题 134
9.1.1 简单算法 135
9.1.2 动态规划 136
9.2 背包问题FAQ 143
9.2.1 再增加一件商品将如何呢 143
9.2.2 行的排列顺序发生变化时结果将如何 145
9.2.3 可以逐列而不是逐行填充网格吗 146
9.2.4 增加一件更小的商品将如何呢 146
9.2.5 可以偷商品的一部分吗 146
9.2.6 旅游行程最优化 147
9.2.7 处理相互依赖的情况 148
9.2.8 计算最终的解时会涉及两个以上的子背包吗 148
9.2.9 最优解可能导致背包没装满吗 149
9.3 最长公共子串 149
9.3.1 绘制网格 150
9.3.2 填充网格 151
9.3.3 揭晓答案 152
9.3.4 最长公共子序列 153
9.3.5 最长公共子序列之解决方案 154
9.4 小结 155
第10 章K最近邻算法 156
10.1 橙子还是柚子 156
10.2 创建推荐系统 158
10.2.1 特征抽取 159
10.2.2 回归 162
10.2.3 挑选合适的特征 164
10.3 机器学习简介 165
10.3.1 OCR 165
10.3.2 创建垃圾邮件过滤器 166
10.3.3 预测股票市场 167
10.4 小结 167
第11 章接下来如何做 168
11.1 树 168
11.2 反向索引 171
11.3 傅里叶变换 171
11.4 并行算法 172
11.5 MapReduce 173
11.5.1 分布式算法为何很有用 173
11.5.2 映射函数 173
11.5.3 归并函数 174
11.6 布隆过滤器和HyperLogLog 174
11.6.1 布隆过滤器 175
11.6.2 HyperLogLog 176
11.7 SHA算法 176
11.7.1 比较文件 177
11.7.2 检查密码 178
11.8 局部敏感的散列算法 178
11.9 Diffie—Hellman密钥交换 179
11.10 线性规划 180
11.11 结语 180
练习答案 181


